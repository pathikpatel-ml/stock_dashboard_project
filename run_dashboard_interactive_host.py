#!/usr/bin/env python
# coding: utf-8

import os
import pandas as pd
from datetime import datetime, date, timedelta
import numpy as np
import sys
import dash
from dash import dcc, html, dash_table
from dash.dependencies import Input, Output, State
import plotly.graph_objects as go
import yfinance as yf # Still needed for individual stock chart

# --- Configuration ---
REPO_BASE_PATH = os.path.dirname(os.path.abspath(__file__))

# Files generated by the daily script
SIGNALS_FILENAME_TEMPLATE = "stock_candle_signals_from_listing_{date_str}.csv"
ATH_TRIGGERS_FILENAME_TEMPLATE = "ath_triggers_data_{date_str}.csv" # New

# Input file for symbols for individual stock analysis dropdown (if different from signals/ath lists)
GROWTH_FILE_NAME = "Master_company_market_trend_analysis.csv" # Or another list if preferred
ACTIVE_GROWTH_DF_PATH = os.path.join(REPO_BASE_PATH, GROWTH_FILE_NAME)


# --- Global DataFrames & Dash App Initialization ---
signals_df_for_dashboard = pd.DataFrame()
ath_triggers_df_for_dashboard = pd.DataFrame() # Will hold pre-calculated ATH triggers
growth_df_for_dashboard = pd.DataFrame() # For the dropdown in individual analysis
all_available_symbols_for_dashboard = [] # For individual stock analysis dropdown

# Display names for loaded files
LOADED_SIGNALS_FILE_DISPLAY_NAME = "N/A"
LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME = "N/A"


app = dash.Dash(__name__, external_stylesheets=['https://codepen.io/chriddyp/pen/bWLwgP.css'])
app.title = "Stock Analysis Dashboard"
server = app.server

# --- Data Loading Logic ---
def load_data_for_dashboard_from_repo():
    global signals_df_for_dashboard, ath_triggers_df_for_dashboard, growth_df_for_dashboard
    global all_available_symbols_for_dashboard
    global LOADED_SIGNALS_FILE_DISPLAY_NAME, LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME

    print(f"\n--- DASH APP: Loading Pre-calculated Data from Daily Scripts ---")
    current_date_str = datetime.now().strftime("%Y%m%d")

    # 1. Load Candle Signals Data (from daily script)
    expected_signals_filename = SIGNALS_FILENAME_TEMPLATE.format(date_str=current_date_str)
    signals_file_path = os.path.join(REPO_BASE_PATH, expected_signals_filename)
    print(f"DASH APP: Attempting to load daily candle signals from: {signals_file_path}")
    if os.path.exists(signals_file_path):
        try:
            signals_df_for_dashboard = pd.read_csv(signals_file_path)
            # Ensure datetime conversion for date columns
            signals_df_for_dashboard['Buy_Date'] = pd.to_datetime(signals_df_for_dashboard['Buy_Date'], errors='coerce')
            signals_df_for_dashboard['Sell_Date'] = pd.to_datetime(signals_df_for_dashboard['Sell_Date'], errors='coerce')
            print(f"DASH APP: Loaded {len(signals_df_for_dashboard)} records from '{expected_signals_filename}'.")
            LOADED_SIGNALS_FILE_DISPLAY_NAME = expected_signals_filename
        except Exception as e:
            print(f"DASH APP ERROR: Could not load or parse signals file '{expected_signals_filename}': {e}")
            signals_df_for_dashboard = pd.DataFrame() # Ensure it's an empty DF on error
            LOADED_SIGNALS_FILE_DISPLAY_NAME = f"{expected_signals_filename} (Error)"
    else:
        print(f"DASH APP WARNING: Daily signals file '{expected_signals_filename}' NOT FOUND.")
        signals_df_for_dashboard = pd.DataFrame()
        LOADED_SIGNALS_FILE_DISPLAY_NAME = f"{expected_signals_filename} (Not Found)"

    # 2. Load ATH Triggers Data (from daily script)
    expected_ath_triggers_filename = ATH_TRIGGERS_FILENAME_TEMPLATE.format(date_str=current_date_str)
    ath_triggers_file_path = os.path.join(REPO_BASE_PATH, expected_ath_triggers_filename)
    print(f"DASH APP: Attempting to load daily ATH triggers data from: {ath_triggers_file_path}")
    if os.path.exists(ath_triggers_file_path):
        try:
            ath_triggers_df_for_dashboard = pd.read_csv(ath_triggers_file_path)
            # Add 'ClosenessAbs (%)' column if not present (for filtering compatibility)
            if 'CMP Proximity to Buy (%)' in ath_triggers_df_for_dashboard.columns and \
               'ClosenessAbs (%)' not in ath_triggers_df_for_dashboard.columns:
                # Convert to numeric, coercing errors, then take absolute
                proximity_numeric = pd.to_numeric(ath_triggers_df_for_dashboard['CMP Proximity to Buy (%)'], errors='coerce')
                ath_triggers_df_for_dashboard['ClosenessAbs (%)'] = proximity_numeric.abs()
            elif 'ClosenessAbs (%)' not in ath_triggers_df_for_dashboard.columns: # If proximity also missing
                 ath_triggers_df_for_dashboard['ClosenessAbs (%)'] = np.inf # Default if cannot calculate


            print(f"DASH APP: Loaded {len(ath_triggers_df_for_dashboard)} records from '{expected_ath_triggers_filename}'.")
            LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME = expected_ath_triggers_filename
        except Exception as e:
            print(f"DASH APP ERROR: Could not load or parse ATH triggers file '{expected_ath_triggers_filename}': {e}")
            ath_triggers_df_for_dashboard = pd.DataFrame()
            LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME = f"{expected_ath_triggers_filename} (Error)"
    else:
        print(f"DASH APP WARNING: Daily ATH triggers file '{expected_ath_triggers_filename}' NOT FOUND.")
        ath_triggers_df_for_dashboard = pd.DataFrame()
        LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME = f"{expected_ath_triggers_filename} (Not Found)"
        
    # 3. Load Growth Data (for individual stock analysis dropdown)
    # This list provides symbols for the chart dropdown. It can be from any source.
    # For simplicity, let's try to populate it from the loaded signals and ATH triggers first,
    # then fallback to the growth file if specified.
    symbols_from_signals = []
    if not signals_df_for_dashboard.empty and 'Symbol' in signals_df_for_dashboard.columns:
        symbols_from_signals = signals_df_for_dashboard['Symbol'].dropna().astype(str).str.upper().unique().tolist()

    symbols_from_ath = []
    if not ath_triggers_df_for_dashboard.empty and 'Symbol' in ath_triggers_df_for_dashboard.columns:
        symbols_from_ath = ath_triggers_df_for_dashboard['Symbol'].dropna().astype(str).str.upper().unique().tolist()
    
    # Fallback to growth file if other lists are empty or if you want it as primary
    symbols_from_growth_file = []
    if os.path.exists(ACTIVE_GROWTH_DF_PATH):
        try:
            growth_df_for_dashboard = pd.read_csv(ACTIVE_GROWTH_DF_PATH)
            if 'Symbol' in growth_df_for_dashboard.columns:
                symbols_from_growth_file = growth_df_for_dashboard['Symbol'].dropna().astype(str).str.upper().unique().tolist()
        except Exception as e:
            print(f"DASH APP WARNING: Could not load growth file '{ACTIVE_GROWTH_DF_PATH}' for dropdown: {e}")
            growth_df_for_dashboard = pd.DataFrame() # Ensure it's an empty DF

    # Combine and unique sort for the dropdown
    combined_symbols = set(symbols_from_signals + symbols_from_ath + symbols_from_growth_file)
    all_available_symbols_for_dashboard = sorted(list(combined_symbols))
    print(f"DASH APP: Total unique symbols for individual analysis dropdown: {len(all_available_symbols_for_dashboard)}")

    return True

# --- yfinance Data Fetching (ONLY for Individual Stock Analysis Chart) ---
def fetch_historical_data_for_graph(symbol_nse_with_suffix):
    try:
        stock_ticker = yf.Ticker(symbol_nse_with_suffix)
        hist_data = stock_ticker.history(period="5y", interval="1d", auto_adjust=False, actions=False, timeout=15)
        if hist_data.empty: return pd.DataFrame()
        hist_data = hist_data.reset_index()
        if 'Date' not in hist_data.columns: return pd.DataFrame() # Check for Date column
        hist_data['Date'] = pd.to_datetime(hist_data['Date']).dt.tz_localize(None)
        required_ohlc = ['Open', 'High', 'Low', 'Close'] # Ensure these exist
        if not all(col in hist_data.columns for col in required_ohlc): return pd.DataFrame()
        for col in required_ohlc: hist_data[col] = pd.to_numeric(hist_data[col], errors='coerce')
        hist_data.dropna(subset=required_ohlc, inplace=True)
        return hist_data
    except Exception as e:
        print(f"DASH APP ERROR fetching graph data for {symbol_nse_with_suffix}: {e}")
        return pd.DataFrame()

# --- Helper for "Stocks Nearest to Buy Signal" module (using pre-loaded signals_df) ---
def get_nearest_to_buy_from_loaded_signals(signals_df_local):
    if signals_df_local.empty or 'Symbol' not in signals_df_local.columns:
        return pd.DataFrame()

    # This module needs current market prices.
    # The daily script *could* add CMP to the signals file, but if not, we fetch it here.
    # For consistency with your request to pre-calculate, ideally, CMP would be in the daily signals file.
    # If CMP is NOT in signals_df_local, we'll fetch it.
    
    df_to_process = signals_df_local.copy()
    
    if 'Latest Close Price' not in df_to_process.columns:
        print("DASH APP (NearestBuy): 'Latest Close Price' not in daily signals file. Fetching CMPs...")
        unique_symbols = df_to_process['Symbol'].dropna().astype(str).str.upper().unique()
        if not unique_symbols.any(): return pd.DataFrame()
        
        yf_symbols = [f"{s}.NS" for s in unique_symbols]
        latest_prices_map = {}
        chunk_size = 50
        for i in range(0, len(yf_symbols), chunk_size):
            chunk = yf_symbols[i:i + chunk_size]
            try:
                data = yf.download(tickers=chunk, period="5d", progress=False, auto_adjust=False, group_by='ticker', timeout=20)
                if not data.empty:
                    for sym_ns in chunk:
                        base_sym = sym_ns.replace(".NS", "")
                        try:
                            price_series = data.get((sym_ns, 'Close')) if isinstance(data.columns, pd.MultiIndex) else data.get('Close')
                            if price_series is not None and not price_series.dropna().empty:
                                latest_prices_map[base_sym] = price_series.dropna().iloc[-1]
                        except Exception: pass
            except Exception as e_yf:
                print(f"DASH APP (NearestBuy): yf.download error for CMPs: {e_yf}")
        
        df_to_process['Latest Close Price'] = df_to_process['Symbol'].astype(str).str.upper().map(latest_prices_map)
        df_to_process.dropna(subset=['Latest Close Price'], inplace=True) # Remove rows where CMP couldn't be fetched

    if df_to_process.empty: return pd.DataFrame()

    results = []
    for _idx, row in df_to_process.iterrows():
        symbol = str(row.get('Symbol','')).upper()
        buy_target = row.get('Buy_Price_Low')
        cmp = row.get('Latest Close Price') # Should exist now

        if not symbol or pd.isna(buy_target) or buy_target == 0 or pd.isna(cmp):
            continue

        prox_pct = ((cmp - buy_target) / buy_target) * 100
        buy_date_str = pd.to_datetime(row.get('Buy_Date')).strftime('%Y-%m-%d') if pd.notna(row.get('Buy_Date')) else 'N/A'
        
        results.append({
            'Symbol': symbol,
            'Signal Buy Date': buy_date_str,
            'Target Buy Price (Low)': round(buy_target, 2),
            'Latest Close Price': round(cmp, 2),
            'Proximity to Buy (%)': round(prox_pct, 2),
            'Closeness (%)': round(abs(prox_pct), 2), # For sorting
            'Potential Gain (%)': round(row.get('Sequence_Gain_Percent', np.nan), 2)
        })

    if not results: return pd.DataFrame()
    return pd.DataFrame(results).sort_values(by=['Closeness (%)', 'Symbol']).reset_index(drop=True)


# --- App Layout Creation Function ---
def create_app_layout():
    global LOADED_SIGNALS_FILE_DISPLAY_NAME, LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME
    global all_available_symbols_for_dashboard

    growth_file_info = os.path.basename(ACTIVE_GROWTH_DF_PATH) if os.path.exists(ACTIVE_GROWTH_DF_PATH) else f"{GROWTH_FILE_NAME} (NF)"

    return html.Div([
        html.H1("Stock Analysis Dashboard", style={'textAlign': 'center', 'color': '#333', 'marginBottom': '5px'}),
        html.P(f"Daily Data: Signals ({LOADED_SIGNALS_FILE_DISPLAY_NAME}) | ATH Triggers ({LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME}) | Symbol List for Chart ({growth_file_info})",
               style={'textAlign': 'center', 'fontSize': 'small', 'color': '#555', 'marginBottom': '20px'}),

        # --- Section 1: Stocks Nearest to Buy Signal (Uses pre-calculated daily signals) ---
        html.Div([
            html.H3("Stocks Nearest to Buy Signal (from Daily Signals File)", style={'textAlign': 'center'}),
            html.Div([
                html.Label("Max Proximity to Buy (%):", style={'marginRight':'5px'}),
                dcc.Input(id='proximity-threshold-input', type='number', value=20, min=0, step=1, style={'marginLeft': '5px', 'marginRight': '15px', 'width':'60px'}),
                html.Button('Apply Filter', id='refresh-nearest-button', n_clicks=0, style={'backgroundColor': '#4CAF50', 'color': 'white', 'border': 'none', 'padding': '8px 12px', 'cursor': 'pointer', 'borderRadius':'5px'})
            ], style={'textAlign': 'center', 'marginBottom': '10px'}),
            dcc.Loading(id="loading-nearest-table", type="circle", children=[
                html.Div(id='nearest-to-buy-table-container', style={'margin': 'auto', 'width': '95%'}) ])
        ], style={'marginBottom': '30px', 'padding': '20px', 'border': '1px solid #ddd', 'borderRadius': '8px', 'backgroundColor': '#f9f9f9'}),

        # --- Section 2: Individual Stock Analysis (Chart uses yfinance, Signals Table uses pre-calculated) ---
        html.Div([
            html.H3("Individual Stock Analysis (Chart & Signals)", style={'textAlign': 'center'}),
            html.Div([
                dcc.Dropdown(
                    id='company-dropdown',
                    options=[{'label': sym, 'value': sym} for sym in all_available_symbols_for_dashboard],
                    value=all_available_symbols_for_dashboard[0] if all_available_symbols_for_dashboard else None,
                    placeholder="Select Company",
                    style={'width': '330px', 'display': 'inline-block', 'marginRight': '10px', 'verticalAlign': 'middle'}
                ),
                dcc.DatePickerRange(
                    id='date-picker-range', min_date_allowed=datetime(2000,1,1), max_date_allowed=datetime.now() + timedelta(days=1),
                    initial_visible_month=datetime.now(), start_date=(datetime.now()-timedelta(days=365*2)).strftime('%Y-%m-%d'),
                    end_date=datetime.now().strftime('%Y-%m-%d'), display_format='YYYY-MM-DD',
                    style={'display': 'inline-block', 'verticalAlign': 'middle'}
                )
            ], style={'marginBottom': '20px', 'textAlign': 'center'}),
            dcc.Loading(id="loading-chart", type="circle", children=dcc.Graph(id='price-chart')),
            html.H4("Signals for Selected Company (from Daily Signals File, in date range):", style={'marginTop': '20px', 'textAlign': 'center'}),
            dcc.Loading(id="loading-signals-table", type="circle", children=[
                 html.Div(id='signals-table-container', style={'margin': 'auto', 'width': '95%'}) ])
        ], style={'marginTop': '30px', 'padding': '20px', 'border': '1px solid #ddd', 'borderRadius': '8px', 'backgroundColor': '#f9f9f9'}),

        # --- Section 3: Strategic ATH Triggers (Uses pre-calculated daily ATH triggers file) ---
        html.Div([
            html.H3("Strategic ATH Triggers (from Daily ATH File)", style={'textAlign': 'center'}),
            html.Div([
                html.Label("Max Proximity to ATH Buy Trigger (%):", style={'marginRight': '5px'}),
                dcc.Input(id='ath-proximity-filter-input', type='number', value=10, min=0, step=1, style={'width': '60px', 'marginRight': '20px', 'verticalAlign': 'middle'}),
                html.Button('Apply ATH Filter', id='refresh-ath-triggers-button', n_clicks=0, style={'backgroundColor': '#007bff', 'color': 'white', 'border': 'none', 'padding': '8px 12px', 'cursor': 'pointer', 'borderRadius':'5px', 'verticalAlign': 'middle'})
            ], style={'textAlign': 'center', 'marginBottom': '20px'}),
            dcc.Loading(id="loading-ath-triggers-table-multi", type="circle", children=[
                html.Div(id='ath-triggers-table-container-multi', style={'margin': 'auto', 'width': '98%'}) ])
        ], style={'marginTop': '30px', 'padding': '20px', 'border': '1px solid #ddd', 'borderRadius': '8px', 'backgroundColor': '#f9f9f9'}),
    ])

# --- Callbacks ---
# Callback for Section 1 (Stocks Nearest to Buy Signal)
@app.callback(
    Output('nearest-to-buy-table-container', 'children'),
    [Input('refresh-nearest-button', 'n_clicks')],
    [State('proximity-threshold-input', 'value')],
    prevent_initial_call=False # Load on app start
)
def update_nearest_to_buy_table(_n_clicks, proximity_threshold_value):
    global signals_df_for_dashboard # Use the globally loaded pre-calculated signals
    
    if signals_df_for_dashboard.empty:
        return html.P(f"Daily signals data not loaded. File: '{LOADED_SIGNALS_FILE_DISPLAY_NAME}' may be missing or empty.", style={'textAlign': 'center', 'color':'red', 'fontWeight':'bold'})

    # This function now might fetch CMPs if not in the daily file.
    nearest_df = get_nearest_to_buy_from_loaded_signals(signals_df_for_dashboard.copy()) 
    
    if nearest_df.empty:
        return html.P("No stocks meet daily signal criteria after processing (or CMP fetch failed if needed).", style={'textAlign': 'center'})
    
    try: proximity_val = float(proximity_threshold_value)
    except (ValueError, TypeError): proximity_val = 20.0 # Default
    
    filtered_df = nearest_df[nearest_df['Closeness (%)'] <= proximity_val]
    
    if filtered_df.empty:
        return html.P(f"No daily signal stocks found within +/- {proximity_val}% of their buy signal.", style={'textAlign': 'center'})
    
    return dash_table.DataTable(
        data=filtered_df.to_dict('records'), columns=[{'name': i, 'id': i} for i in filtered_df.columns],
        page_size=15, sort_action="native", filter_action="native",
        style_table={'overflowX': 'auto', 'width': '100%'},
        style_cell={'textAlign': 'left', 'minWidth': '90px', 'width': '140px', 'maxWidth': '180px', 'whiteSpace': 'normal', 'padding': '5px', 'fontSize':'0.85em'},
        style_header={'backgroundColor': 'rgb(230, 230, 230)', 'fontWeight': 'bold', 'border': '1px solid grey'},
        style_data={'border': '1px solid grey'}
    )

# Callback for Section 2 (Individual Stock Chart)
@app.callback(
    Output('price-chart', 'figure'),
    [Input('company-dropdown', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date')]
)
def update_graph(selected_company, start_date_str, end_date_str):
    # This still uses yfinance for the chart as it's for a single selected company
    if not selected_company:
        return go.Figure().update_layout(title="Select a company for the chart", template="plotly_white", paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
    try:
        start_date = pd.to_datetime(start_date_str).normalize()
        end_date = pd.to_datetime(end_date_str).normalize()
    except Exception:
        return go.Figure().update_layout(title="Invalid date format for chart", template="plotly_white", paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
    
    hist_df = fetch_historical_data_for_graph(f"{selected_company.upper().strip()}.NS") # Fetches fresh
    
    if hist_df.empty or 'Date' not in hist_df.columns:
        return go.Figure().update_layout(title=f"No historical data found for {selected_company}", template="plotly_white", paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
    
    hist_df_filtered = hist_df[(hist_df['Date'] >= start_date) & (hist_df['Date'] <= end_date)]
    if hist_df_filtered.empty:
        return go.Figure().update_layout(title=f"No data for {selected_company} in selected date range", template="plotly_white", paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
    
    fig = go.Figure(data=[go.Candlestick(x=hist_df_filtered['Date'], open=hist_df_filtered['Open'], high=hist_df_filtered['High'], low=hist_df_filtered['Low'], close=hist_df_filtered['Close'], name='OHLC')])
    
    # Add signals from the loaded signals_df_for_dashboard to the chart
    if not signals_df_for_dashboard.empty and 'Symbol' in signals_df_for_dashboard.columns:
        company_signals_on_chart = signals_df_for_dashboard[signals_df_for_dashboard['Symbol'].astype(str).str.upper() == selected_company.upper()].copy()
        if not company_signals_on_chart.empty:
            for _, row in company_signals_on_chart.iterrows():
                buy_dt, sell_dt = row['Buy_Date'], row['Sell_Date'] # Already datetime
                if pd.isna(buy_dt): continue

                show_signal_on_chart = False
                # Signal visible if its period [buy_dt, sell_dt_or_chart_end] overlaps with [start_date, end_date] of chart
                if pd.notna(sell_dt): # Closed signal
                    if (buy_dt <= end_date) and (sell_dt >= start_date):
                        show_signal_on_chart = True
                else: # Open signal (sell_dt is NaT)
                    if buy_dt <= end_date: # Show if it started before or during the visible chart range
                        show_signal_on_chart = True
                
                if show_signal_on_chart:
                    plot_x_coords = [buy_dt]
                    plot_y_coords = [row['Buy_Price_Low']]
                    if pd.notna(sell_dt):
                        plot_x_coords.append(sell_dt)
                        plot_y_coords.append(row['Sell_Price_High'])
                    
                    fig.add_trace(go.Scatter(
                        x=plot_x_coords, y=plot_y_coords, mode='lines+markers' if len(plot_x_coords) > 1 else 'markers',
                        name=f"Signal Gain: {row.get('Sequence_Gain_Percent', 0):.1f}%" if pd.notna(sell_dt) else "Open Signal",
                        line=dict(color='rgba(128,0,128,0.7)', width=2, dash='dot'), marker=dict(symbol='circle', size=8, color='purple')
                    ))
                    fig.add_annotation(x=buy_dt, y=row['Buy_Price_Low'], text="B", showarrow=True, arrowhead=2, arrowcolor="green", bgcolor="rgba(200,255,200,0.7)", ax=0, ay=-25, font=dict(size=9))
                    if pd.notna(sell_dt):
                         fig.add_annotation(x=sell_dt, y=row['Sell_Price_High'], text="S", showarrow=True, arrowhead=2, arrowcolor="red", bgcolor="rgba(255,200,200,0.7)", ax=0, ay=25, font=dict(size=9))

    fig.update_layout(title=f'{selected_company} Price Chart', xaxis_rangeslider_visible=False, xaxis_title='Date', yaxis_title='Price (INR)', template="plotly_white", legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1), paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
    return fig

# Callback for Section 2 (Signals Table for Selected Company)
@app.callback(
    Output('signals-table-container', 'children'),
    [Input('company-dropdown', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date')]
)
def update_signals_table(selected_company, start_date_str, end_date_str):
    global signals_df_for_dashboard # Use the globally loaded pre-calculated signals

    if not selected_company:
        return html.P("Select a company to see its signals.", style={'textAlign': 'center'})
    if not start_date_str or not end_date_str:
        return html.P("Please select a valid date range for signals.", style={'textAlign': 'center', 'color': 'red'})

    try:
        filter_start_date = pd.to_datetime(start_date_str).normalize()
        filter_end_date = pd.to_datetime(end_date_str).normalize()
    except Exception:
        return html.P("Invalid date format for signals table.", style={'textAlign': 'center', 'color': 'red'})

    if signals_df_for_dashboard.empty:
        return html.P(f"Daily signals data not loaded. File: '{LOADED_SIGNALS_FILE_DISPLAY_NAME}' may be missing or empty.", style={'textAlign': 'center', 'color':'orange', 'fontWeight':'bold'})

    company_signals_df = signals_df_for_dashboard[signals_df_for_dashboard['Symbol'].astype(str).str.upper() == selected_company.upper()].copy()
    
    if company_signals_df.empty:
        return html.P(f"No signals found for {selected_company} in the loaded daily data.", style={'textAlign': 'center'})

    # Filter signals by date range
    valid_buy = company_signals_df['Buy_Date'].notna()
    closed_filter = valid_buy & company_signals_df['Sell_Date'].notna() & \
                    (company_signals_df['Buy_Date'] <= filter_end_date) & \
                    (company_signals_df['Sell_Date'] >= filter_start_date)
    open_filter = valid_buy & company_signals_df['Sell_Date'].isna() & \
                  (company_signals_df['Buy_Date'] <= filter_end_date)
                  
    df_filtered = company_signals_df[closed_filter | open_filter].copy()

    if df_filtered.empty:
        return html.P(f"No signals found for {selected_company} within the selected date range.", style={'textAlign': 'center'})

    # Format dates for display AFTER filtering
    for col in ['Buy_Date', 'Sell_Date']:
        if col in df_filtered.columns and pd.api.types.is_datetime64_any_dtype(df_filtered[col]):
            df_filtered[col] = df_filtered[col].dt.strftime('%Y-%m-%d')
    df_filtered.fillna('N/A', inplace=True) # For open Sell_Date
    
    return dash_table.DataTable(
        data=df_filtered.to_dict('records'), columns=[{'name': i, 'id': i} for i in df_filtered.columns],
        page_size=10, sort_action="native",
        style_table={'overflowX': 'auto', 'width': '100%'},
        style_cell={'textAlign': 'left', 'minWidth': '90px', 'width': '140px', 'maxWidth': '180px', 'whiteSpace': 'normal', 'padding': '5px', 'fontSize':'0.85em'},
        style_header={'backgroundColor': 'rgb(230, 230, 230)', 'fontWeight': 'bold', 'border': '1px solid grey'},
        style_data={'border': '1px solid grey'}
    )

# Callback for Section 3 (Strategic ATH Triggers - Multi-Company Table from pre-calculated file)
@app.callback(
    Output('ath-triggers-table-container-multi', 'children'),
    [Input('refresh-ath-triggers-button', 'n_clicks')], # Button applies filter
    [State('ath-proximity-filter-input', 'value')],
    prevent_initial_call=False # Load on app start by applying default filter
)
def update_ath_triggers_multi_table(_n_clicks, proximity_filter_value):
    global ath_triggers_df_for_dashboard # Use the globally loaded pre-calculated ATH data

    if ath_triggers_df_for_dashboard.empty:
        return html.P(f"Daily ATH triggers data not loaded. File: '{LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME}' may be missing, empty, or had loading errors.", style={'textAlign': 'center', 'color': 'orange', 'fontWeight':'bold'})

    try:
        proximity_threshold = float(proximity_filter_value)
        if proximity_threshold < 0: proximity_threshold = 10.0 # Default if negative
    except (ValueError, TypeError):
        proximity_threshold = 10.0 # Default if input is invalid

    # Ensure 'ClosenessAbs (%)' exists for filtering
    # This should have been added during `load_data_for_dashboard_from_repo`
    if 'ClosenessAbs (%)' not in ath_triggers_df_for_dashboard.columns:
        if 'CMP Proximity to Buy (%)' in ath_triggers_df_for_dashboard.columns:
            # Attempt to create it on the fly if somehow missed, but ideally it's pre-calculated
            proximity_numeric = pd.to_numeric(ath_triggers_df_for_dashboard['CMP Proximity to Buy (%)'], errors='coerce')
            data_to_filter = ath_triggers_df_for_dashboard.copy()
            data_to_filter['ClosenessAbs (%)'] = proximity_numeric.abs()
        else: # Cannot filter if essential column is missing
             return html.P("Cannot filter ATH Triggers: 'CMP Proximity to Buy (%)' column is missing from the loaded data.", style={'textAlign': 'center', 'color': 'red'})
    else:
        data_to_filter = ath_triggers_df_for_dashboard.copy()


    filtered_df = data_to_filter[data_to_filter['ClosenessAbs (%)'] <= proximity_threshold]
    
    # Drop the helper ClosenessAbs column before display if it was temporarily added or exists
    filtered_df_display = filtered_df.drop(columns=['ClosenessAbs (%)'], errors='ignore')

    if filtered_df_display.empty:
        return html.P(f"No profit companies found within {proximity_threshold}% proximity to their ATH Buy Trigger (using data from '{LOADED_ATH_TRIGGERS_FILE_DISPLAY_NAME}').", style={'textAlign': 'center'})

    return dash_table.DataTable(
        data=filtered_df_display.to_dict('records'),
        columns=[{'name': i, 'id': i} for i in filtered_df_display.columns],
        page_size=20, sort_action="native", filter_action="native",
        style_table={'overflowX': 'auto', 'width': '100%'},
        style_cell={'textAlign': 'left', 'minWidth': '100px', 'width': 'auto', 'maxWidth': '200px', 'whiteSpace': 'normal', 'padding': '6px', 'fontSize':'0.85em'},
        style_header={'backgroundColor': 'rgb(210, 220, 255)', 'fontWeight': 'bold', 'border': '1px solid grey'},
        style_data={'border': '1px solid grey'},
    )

# --- Application Initialization Sequence ---
print("DASH APP: Initializing application for web server...")
load_data_for_dashboard_from_repo() # Load all pre-calculated data at startup
app.layout = create_app_layout
print("DASH APP: App layout assigned.")
print("DASH APP: Application initialized. Ready for requests.")

# --- Main execution block ---
if __name__ == '__main__':
    print("DASH APP: Starting Dash development server (for local testing)...")
    app.run_server(debug=True, host='0.0.0.0', port=8050)
